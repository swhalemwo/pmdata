

gd_artnews_time <- function(ARTNEWS_TIME_FILE = PMDATA_LOCS$ARTNEWS_TIME_FILE) {
    if (as.character(match.call()[[1]]) %in% fstd){browser()}
    1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;
    

    dt_artnews_time <- fread(ARTNEWS_TIME_FILE)

    ## check whether location is handled properly: yea seems to be unique within collector
    dt_artnews_time[, .N, clctr_name]
    dt_artnews_time[, .N, .(clctr_name, location)]
    dt_artnews_time[grepl("David Bowie", clctr_name)]

    ## look at couples, "and" seems to be pretty good differentiator
    dt_artnews_time[grepl("and", clctr_name), .N, clctr_name] %>% print(n=300)

    
}

PMDATA_LOCS <- gc_pmdata_locs()
gd_artnews_time()


#' generate the artnews collector file
#' here manually it has to be checked manually whether a collector entry in artnews ranking refers to single person
#' @param ARTNEWS_TIME_FILE the year-ranking-collector file
#' @param ARTNEWS_COLLECTOR_ENTRIES_FILE the output that gets produced: unique collectors, with ID (Artnews-collector-entity, ACE) and heuristic of whether they are a couple
gwd_artnews_clctr <- function(ARTNEWS_TIME_FILE = PMDATA_LOCS$ARTNEWS_TIME_FILE,
                              ARTNEWS_COLLECTOR_ENTRIES_FILE = PMDATA_LOCS$ARTNEWS_COLLECTOR_ENTRIES_FILE) {

    dt_artnews_time <- fread(ARTNEWS_TIME_FILE)

    ## heuristic coding ("and" present)  whether collector refers to couple
    dt_artnews_time[, .(clctr_name = funique(clctr_name))] %>%
        .[, .(an_entry_id = paste0("ACE", 1:.N), clctr_name,
              is_couple = fifelse(grepl(" and ", clctr_name), 1, 0))] %>%        
        fwrite(paste0(ARTNEWS_COLLECTOR_ENTRIES_FILE))

}

## ONLY RUN ONCE:
## the ARTNEWS_COLLECTOR_ENTRIES_FILE has to be checked manually whether the heuristic coding is correct
## gwd_artnews_clctr()

#' reads ARTNEWS_COLLECTOR_ENTRIES_FILE, duplicates couple rows to make reduction to person simpler
#'
#' e.g. entry "John Doe and Jane Smith" is repeated twice in ARTNEWS_COLLECTOR_PERSON_FILE (since in previous step in gwd_artnews_clctr) identified as couple, and is now replaced manually by two entries, "John Doe" and "Jane Smith" (deleting takes less keystrokes than expanding)
#' manual checking takes place in org-mode due to better table-editing capabilities (edits don't yeet indentation, which is the case in csv-mode). `an_clctr_person.org` is manually generated from ARTNEWS_COLLECTOR_ENTRIES_FILE via macros/replace-string, and then exported to via `org-table-export` to .csv (ARTNEWS_COLLECTOR_PERSON_FILE_ORG)
#' @param ARTNEWS_COLLECTOR_ENTRIES_FILE file generated by gwd_artnews_clctr, !!!AFTER BEING MANUALLY CHECKED THAT ALL COLLECTOR ENTRIES INDICATED TO BE COUPLES ARE IN FACT COUPLES!!!
#' @param ARTNEWS_COLLECTOR_PERSON_FILE ARTNEWS_COLLECTOR_ENTRIES_FILE, but with duplicated couple rows so that reduction to persons is easier. also has a person ID (Artnews person entity, "APE"; with indexing for couples, .e.g "APE10b" for second person in collector couple that is ACE10
gwd_artnews_collector_person <- function(
          ARTNEWS_COLLECTOR_ENTRIES_FILE = PMDATA_LOCS$ARTNEWS_COLLECTOR_ENTRIES_FILE,
          ARTNEWS_COLLECTOR_PERSON_FILE = PMDATA_LOCS$ARTNEWS_COLLECTOR_PERSON_FILE) {
    if (as.character(match.call()[[1]]) %in% fstd){browser()}
    1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;

    
    dt_an_clctr_entries <- fread(ARTNEWS_COLLECTOR_ENTRIES_FILE)
    
    ## already copy the couple lines, saves manually copying (just have to delete the wrong parts)
    dt_an_person_prep <- rbind(dt_an_clctr_entries, dt_an_clctr_entries[is_couple==1]) %>% 
        .[, ace_nbr := as.integer(substring(an_entry_id, 4, nchar(an_entry_id)))] %>%
        .[, an_person_id := paste0("APCE", ace_nbr, letters[1:.N]), an_entry_id] %>%
        .[order(-is_couple, ace_nbr)] %>%
        .[, .(an_entry_id, an_person_id, clctr_name, is_couple)]

        
    fwrite(dt_an_person_prep, ARTNEWS_COLLECTOR_PERSON_FILE)
    ## dt_an_person_prep
}
        


        
## ONLY RUN ONCE:
## this duplicates couple rows so that manual deletion is easier
## names are not standardized for automatic detection of both names
## gwd_artnews_collector_person()

#' add the APE ID to ARTNEWS_COLLECTOR_PERSON_FILE
#' 
mwd_artnews_collector_person <- function(
    ARTNEWS_COLLECTOR_PERSON_FILE_ORG = PMDATA_LOCS$ARTNEWS_COLLECTOR_PERSON_FILE_ORG,
    ARTNEWS_APECPRN_FILE = PMDATA_LOCS$ARTNEWS_APECPRN_FILE) {
    if (as.character(match.call()[[1]]) %in% fstd){browser()}
    1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;


    ## this should not be in package declaration: stringdist used only once for setup?
    ## maybe add later when I have the maintenance added
    library(stringdist, include.only = c("stringdist", "stringdistmatrix"))
    

    dt_acpe <- fread(ARTNEWS_COLLECTOR_PERSON_FILE_ORG) %>%
        .[, an_person_id := 1:.N] # assign ID first

    if  (any_duplicated(dt_acpe$an_person_collector_id)) {stop("ACPEs not unique")}
    

    ## get cases where name is literally duplicate
    dt_simpledups <- dt_acpe[, .N, clctr_name][N>1] %>%
        dt_acpe[., on = "clctr_name"] %>% # get all APE
        .[, .SD[which.min(an_person_id)], clctr_name]   # get first ID

    ## reassign simple duplicates with update join 
    dt_acpe_w_id1 <- copy(dt_acpe)[dt_simpledups, an_person_id := i.an_person_id, on = "clctr_name"]

    ## prep for pairwise comparison
    dt_strindist_prep <- dt_acpe_w_id1[, .(an_person_id, clctr_name)] %>% funique


    dt_stringdist_mat <- stringdistmatrix(dt_strindist_prep[, clctr_name], dt_strindist_prep[, clctr_name],
                                          useNames = "strings") %>% adt %>% 
                         .[, clctr_name := dt_strindist_prep[, clctr_name]]

    dt_stringdist_long <- melt(dt_stringdist_mat, id.vars = "clctr_name", variable.name = "clctr_name2",
                               value.name = "dist")

    dt_stringdist_close <- dt_stringdist_long[(clctr_name != clctr_name2) & dist < 5][order(dist)] 

    ## get collector entries as list
    ## get ACEs of clctr_name
    dt_ace_left <- dt_acpe_w_id1[dt_stringdist_close, on = "clctr_name"] %>%
        .[, .(ace_left = paste(sort(unique(an_entry_id)), collapse = "--")), clctr_name]

    ## get ACEs of clctr_name2
    dt_ace_right <- dt_acpe_w_id1[dt_stringdist_close, on = .(clctr_name = clctr_name2)] %>% 
        .[, .(ace_right = paste(sort(unique(an_entry_id)), collapse = "--")), clctr_name]

    
    library(furrr)
    plan(multicore, workers = 4)
    plan(sequential)

    
    dt_stringdist_long[grepl("Capriles", clctr_name) & grepl("Capriles", clctr_name2)]

    ## subsetting: whether all terms of one are terms of other, e.g. "John Meier" and "John Meyer Smith" and 
    dt_subset <- dt_stringdist_long %>% copy() %>% # head(n=10000) %>% 
        .[, `:=`(terms1 = list(strsplit(clctr_name, split = " ")),
                 terms2 = list(strsplit(as.character(clctr_name2), split = " "))),          
          .(clctr_name, clctr_name2)] %>%
        .[, subset := future_map2_int(terms1, terms2, ~(all(.x %in% .y)|all(.y %in% .x)))]

    dt_subset %>% .[subset==1 & dist != 0]

    ## this should subset match, but doesn't
    dt_subset[grepl("Capriles", clctr_name) & grepl("Capriles", clctr_name2)] %>% copy() %>% 
        .[, kappa := map2_int(terms1, terms2, ~all(.x %in% .y))] %>% adf

    ## elsewhere it can match the identical situation
    dt_ree <- data.table(x=list(list("Miguel", "Capriles")), y= list(list("Miguel", "Angel", "Capriles")))
    dt_ree %>% adf
    dt_ree[, kappa := map2_int(x, y, ~all(.x %in% .y))]
    dt_ree[, lapply(.SD, \(x,y) x %in% y), .SDcols = .c(x,y)]
    
                 

    l1 <- list("Miguel","Capriles")
    l2 <- list("Miguel", "Angel", "Capriles")

    all(l1 %in% l2) | all(l2 %in% l1)


    ## get all relevant comparisons
    dt_ape_cprn <- dt_stringdist_close[dt_ace_left, on = "clctr_name"] %>% # join left
        .[dt_ace_right, on = .(clctr_name2 = clctr_name)] %>% # join right
        .[!ace_left == ace_right & clctr_name > clctr_name2] %>% ## yeet couples and reverse
        .[order(dist)] %>%
        .[, `:=`(is_same_APE = 0, correct_name = "")]
    
    dt_ape_cprn[grepl("Vogel", clctr_name)]

    fwrite(dt_ape_cprn, ARTNEWS_APECPRN_FILE)

    dt_artnews_time <- fread(PMDATA_LOCS$ARTNEWS_TIME_FILE)
    dt_artnews_time[grepl("Hahnloser", clctr_name)] %>% print(n=30)
    dt_artnews_time[grepl("Lewis", clctr_name) & grepl("Joseph|Joe", clctr_name)] %>% print(n=30)

    
    dt_acpe[grepl("Capriles", clctr_name)]

    ## if (nrow(dt_apce) != nrow(dt_apce_w_id)) {stop("number of rows not the same")}



    ## dt_apce[, .N, clctr_name][N>1] %>% 
    ## dt_apce[grepl("Rachel Mellon", clctr_name)]


    ## dt_ace <- fread(PMDATA_LOCS$ARTNEWS_COLLECTOR_ENTRIES_FILE)
    ## dt_ace[grepl("Mellon", clctr_name)]
}


mwd_artnews_collector_person()
